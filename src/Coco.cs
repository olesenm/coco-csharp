/*---------------------------------------------------------------------------*\
    Compiler Generator Coco/R,
    Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
    extended by M. Loeberbauer & A. Woess, Univ. of Linz
    with improvements by Pat Terry, Rhodes University
-------------------------------------------------------------------------------
License
    This file is part of Compiler Generator Coco/R

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2, or (at your option) any
    later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

    As an exception, it is allowed to write an extension of Coco/R that is
    used as a plugin in non-free software.

    If not otherwise stated, any source code generated by Coco/R (other than
    Coco/R itself) does not fall under the GNU General Public License.
\*---------------------------------------------------------------------------*/
/*!

@mainpage The Compiler Generator Coco/R, C# version.

http://www.ssw.uni-linz.ac.at/coco/

@section usage Program Usage

@verbatim
coco-cs Grammar.atg {Option}
Options:
  -namespace <Name>      eg, My.Name.Space
  -prefix    <Name>      for unique Parser/Scanner file names
  -frames    <Dir>       for frames not in the source directory
  -trace     <String>    trace with output to trace.txt
  -trace2    <String>    trace with output on stderr
  -o         <Dir>       output directory
  -bak                   save existing Parser/Scanner files as .bak
  -help                  print this usage
@endverbatim
The valid trace string values are listed below.

The Scanner.frame and Parser.frame must be located in one of these
directories:
-# The same directory as the atg grammar.
-# In the specified -frames directory.

Unless specified with the @em -o option, the generated scanner/parser
files are written in the same directory as the atg grammar!

@section trace Trace output options

 - 0 | A: prints the states of the scanner automaton
 - 1 | F: prints the First and Follow sets of all nonterminals
 - 2 | G: prints the syntax graph of the productions
 - 3 | I: traces the computation of the First sets
 - 4 | J: prints the sets associated with ANYs and synchronisation sets
 - 6 | S: prints the symbol table (terminals, nonterminals, pragmas)
 - 7 | X: prints a cross reference list of all syntax symbols
 - 8 | P: prints statistics about the Coco run
 - 9    : unused

The trace output can be switched on as a command-line option or by
the pragma:
@verbatim
    $ { digit | letter }
@endverbatim
in the attributed grammar.

The extended directive format may also be used in the attributed grammar:
@verbatim
    $trace=(digit | letter){ digit | letter }
@endverbatim

@section Compiler Directives (Extended Pragmas)

To improve the reliability of builds in complex environments, it is
possible to specify the desired namespace and/or file prefix as a
directive within the grammar. For example, when compiling the
Coco-cs.atg itself, it can be compiled within the 'Coco' namespace
as specified on the command-line. For example,

@verbatim
    coco-cs -namespace Coco Coco-cs.atg
@endverbatim

As an alternative, it can be specified within the Coco-cs.atg file:
@verbatim
    COMPILER Coco
    $namespace=Coco
@endverbatim

For completeness, it is also possible to add in trace string parameters
with the same syntax. For example,

@verbatim
    COMPILER GramC
    $trace=ags
@endverbatim

*/
/*-------------------------------------------------------------------------*/
using System;
using System.IO;

namespace at.jku.ssw.Coco {

//! Entry point for standalone program
public class Coco {

	//! The version number (should correspond to the ISO-date)
	public const string VERSION = "20101106";

	static void printUsage (string message)
	{
		if (message != null) {
			Console.WriteLine("Error: {0}", message);
		}

		Console.WriteLine
		(
			"Usage: coco-cs Grammar.atg {{Option}}{0}" +
			"Options:{0}" +
			"  -namespace <Name>      eg, My.Name.Space{0}" +
			"  -prefix    <Name>      for unique Parser/Scanner file names{0}" +
			"  -frames    <Dir>       for frames not in the source directory{0}" +
			"  -trace     <String>    trace with output to trace.txt{0}" +
			"  -trace2    <String>    trace with output on stderr{0}" +
			"  -o         <Dir>       output directory{0}" +
			"  -bak                   save existing Parser/Scanner files as .bak{0}" +
			"  -help                  print this usage{0}" +
			"{0}Valid characters in the trace string:{0}" +
			"  A  trace automaton{0}" +
			"  F  list first/follow sets{0}" +
			"  G  print syntax graph{0}" +
			"  I  trace computation of first sets{0}" +
			"  J  list ANY and SYNC sets{0}" +
			"  P  print statistics{0}" +
			"  S  list symbol table{0}" +
			"  X  list cross reference table{0}" +
			"Scanner.frame and Parser.frame must be located in one of these directories:{0}" +
			"  1. The same directory as the atg grammar.{0}" +
			"  2. In the specified -frames directory.{0}" +
			"{0}http://www.ssw.uni-linz.ac.at/coco/{0}{0}",
			Environment.NewLine
		);
	}

	public static int Main (string[] arg)
	{
		Console.WriteLine("Coco/R C#, version: {0}", VERSION);

		string srcName = null, nsName = null, prefixName = null;
		string frameDir = null, ddtString = null, outDir = null;
		bool makeBackup = false;
		bool traceToFile = true;
		int retVal = 1;

		// pass 1: find -help, -version options
		foreach (string opt in arg) {
			if (opt == "-help") {
				printUsage(null);
				return 0;
			}
			if (opt == "-version") {
				// version already printed above
				return 0;
			}
		}

		// pass 2: process other options
		for (int i = 0; i < arg.Length; i++) {
			if (arg[i] == "-namespace") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -namespace");
					return retVal;
				}
				nsName = arg[i];
			}
			else if (arg[i] == "-prefix") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -prefix");
					return retVal;
				}
				prefixName = arg[i];
			}
			else if (arg[i] == "-frames") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -frames");
					return retVal;
				}
				frameDir = arg[i];
			}
			else if (arg[i] == "-trace") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -trace");
					return retVal;
				}
				traceToFile = true;
				ddtString = arg[i];
			}
			else if (arg[i] == "-trace2") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -trace2");
					return retVal;
				}
				traceToFile = false;
				ddtString = arg[i];
			}
			else if (arg[i] == "-o") {
				if (++i == arg.Length) {
					printUsage("missing parameter on -o");
					return retVal;
				}
				outDir = arg[i];
			}
			else if (arg[i] == "-bak") {
				makeBackup = true;
			}
			else if (arg[i][0] == '-') {
				printUsage("unknown option: '" + arg[i] + "'");
				return retVal;
			}
			else if (srcName != null) {
				printUsage("grammar can only be specified once");
				return retVal;
			}
			else {
				srcName = arg[i];
			}
		}

		if (srcName != null)
		{
			string traceFileName = null;
			try {
				string srcDir = Path.GetDirectoryName(srcName);

				Scanner scanner = new Scanner(srcName);
				Parser parser   = new Parser(scanner);
				parser.tab      = new Tab(parser);

				parser.tab.srcName    = srcName;
				parser.tab.srcDir     = srcDir;
				parser.tab.nsName     = nsName;
				parser.tab.prefixName = prefixName;
				parser.tab.frameDir = frameDir;
				parser.tab.outDir   = (outDir != null) ? outDir : srcDir;
				parser.tab.SetDDT(ddtString);
				parser.tab.makeBackup = makeBackup;

				if (traceToFile) {
					traceFileName = Path.Combine(parser.tab.outDir, "trace.txt");
					parser.tab.trace = new StreamWriter(new FileStream(traceFileName, FileMode.Create));
				}
				parser.dfa = new DFA(parser);
				parser.pgen = new ParserGen(parser);

				parser.Parse();

				if (traceToFile) {
					parser.tab.trace.Close();
					FileInfo f = new FileInfo(traceFileName);
					if (f.Length == 0) f.Delete();
					else Console.WriteLine("trace output is in " + traceFileName);
				}
				Console.WriteLine("{0} errors detected", parser.errors.count);
				if (parser.errors.count == 0) { retVal = 0; }
			} catch (IOException) {
				Console.WriteLine("-- could not open " + traceFileName);
			} catch (FatalError e) {
				Console.WriteLine("-- " + e.Message);
			}
		} else {
			printUsage(null);
		}
		return retVal;
	}

} // end Coco


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // end namespace

// ************************************************************************* //
